#set $len_entries = len($entries)
extern int __${pre}nonull(1) __warn_result ${deprecated}
${check}(const ${type} * value)
{
	${assert_fn}(value);

#for $e in $entries
#if 'repeated' in $e
#if isinstance(e.repeated, (int, str))
	for (unsigned int i = 0; i < ${e.repeated}; i++) {
#else
	for (unsigned int i = 0; i < value->${e.id}_nb; i++) {
#end if
		if (${e.check}(${e.ampersand}value->${e.id}[i]))
			return 1;
	}
#else
	if (${e.check}(${e.ampersand}value->${e.id}))
		return 1;
#end if

#end for
#if $app_check
	return ${app_check}(value);
#else
	return 0;
#end if
}

#for $e in $entries
#if 'repeated' in $e
static int __${pre}nonull(1, 3)
${decode}_array_${e.id}(struct dpack_decoder * decoder,
#if isinstance(e.repeated, (int, str))
			unsigned int id,
#else
			unsigned int id __unused,
#end if
			void * __restrict ctx)
{
	${assert_fn}(decoder);
	${assert_fn}(ctx);
#if isinstance(e.repeated, (int, str))
	${assert_fn}(id < ${e.repeated});
#else
	${assert_fn}(id >= ${e.repeated.min});
	${assert_fn}(id < ${e.repeated.max});
#end if

	${type} *value = ctx;
#if isinstance(e.repeated, (int, str))

	return ${e.decode}(decoder, &value->${e.id}[id]);
#else
	${e.type} *tmp;

	tmp = ${pid}_append_${e.id}(value);
	if (!tmp)
		return -ENOMEM;

	return ${e.decode}(decoder, tmp);
#end if
}

#end if
#end for
extern int __${pre}nonull(1, 2) __nothrow __warn_result ${deprecated}
${decode}(struct dpack_decoder * decoder,
	  ${type} * __restrict value)
{
	${assert_fn}(decoder);
	${assert_fn}(value);

	int ret;

	ret = dpack_array_decode_count_equ(decoder, ${len_entries});
	if (ret)
		return ret;

#for $e in $entries
#if 'repeated' in $e
#if isinstance(e.repeated, (int, str))
	ret = dpack_array_decode_equ(decoder, ${e.repeated},
				     ${decode}_array_${e.id},
				     value);
#else
	ret = dpack_array_decode_range(decoder, ${e.repeated.min}, ${e.repeated.max},
				       ${decode}_array_${e.id},
				       value);
#end if
	if (ret)
		return ret;
#else
	ret = ${e.decode}(decoder, &value->${e.id});
	if (ret)
		return ret;
#end if

#end for
	return ${check}(value);
}

extern int __${pre}nonull(1) __nothrow __warn_result ${deprecated}
${encode}(struct dpack_encoder * encoder,
	  const ${type} * value)
{
	${assert_fn}(encoder);
	${assert_fn}(${check}(value) == 0);

	int ret;

	ret = dpack_array_begin_encode(encoder, ${len_entries});
	if (ret)
		return ret;

#for $e in $entries
#if 'repeated' in $e
#if isinstance(e.repeated, (int, str))
	ret = dpack_array_begin_encode(encoder, ${e.repeated});
#else
	ret = dpack_array_begin_encode(encoder, value->${e.id}_nb);
#end if
	if (ret)
		return ret;

#if isinstance(e.repeated, (int, str))
	for (unsigned int i = 0; i < ${e.repeated}; i++) {
#else
	for (unsigned int i = 0; i < value->${e.id}_nb; i++) {
#end if
		ret = ${e.encode}(encoder, ${e.ampersand}value->${e.id}[i]);
		if (ret)
			return ret;
	}

	dpack_array_end_encode(encoder);
#else
	ret = ${e.encode}(encoder, ${e.ampersand}value->${e.id});
	if (ret)
		return ret;
#end if

#end for

	return 0;
}

extern int __${pre}nonull(1) __warn_result ${deprecated}
${init}(${type} * value __unused)
{
	${assert_fn}(value);

	int ret = 0;

#for $e in $entries
#if 'repeated' in $e
#if isinstance(e.repeated, (int, str))
#if $e.init
	for (unsigned int i = 0; i < ${e.repeated}; i++) {
		ret = ${e.init}(&value->${e.id}[i]);
		if (ret)
			return ret;
	}

#end if
#else
	value->${e.id}_nb = 0;
	value->${e.id} = NULL;
#end if
#else
#if $e.init
	ret = ${e.init}(&value->${e.id});
	if (ret)
		return ret;

#end if
#end if
#end for
	return ret;
}

extern void __${pre}nonull(1) ${deprecated}
${fini}(${type} * value __unused)
{
	${assert_fn}(value);

#for $e in $entries
#if 'repeated' in $e
#set $r = e.repeated if isinstance(e.repeated, (int, str)) else f"value->{e.id}_nb"
#if $e.fini
	for (unsigned int i = 0; i < ${r}; i++)
		${e.fini}(&value->${e.id}[i]);
#end if
#if not isinstance(e.repeated, (int, str))
	free(value->${e.id});
#end if
#else
#if $e.fini
	${e.fini}(&value->${e.id});
#end if
#end if
#end for
}
#for $e in $entries
#if 'repeated' in $e and not isinstance(e.repeated, (int, str))

${e.type} *__${pre}nonull(1) ${deprecated}
${pid}_append_${e.id}(${type} * data)
{
	${assert_fn}(data);

	void *ptr;
#if $e.init
	int   ret;
#end if

	if (data->${e.id}_nb >= (${e.repeated.max} - 1))
		return NULL;
	
	ptr = reallocarray(data->${e.id}, data->${e.id}_nb + 1, sizeof(${e.type}));
	if (!ptr)
		return NULL;

	data->${e.id} = ptr;
#if $e.init
	ret = ${e.init}(&data->${e.id}[data->${e.id}_nb]);
	if (ret) {
		errno = -ret;
		return NULL;
	}

#end if
	data->${e.id}_nb++;
	return &data->${e.id}[data->${e.id}_nb - 1];
}
#end if
#end for

## ex: filetype=c
