/******************************************************************************
 * SPDX-License-Identifier: MIT-0
 *
 * This file is part of ${name}.
 * This file is generated by troer, don't edit manually.
 ******************************************************************************/

#if $kconfig
\#include <${name}/lib.h>
#else if $args.include_prefix
\#include <${args.include_prefix}${name}.h>
#else
\#include "${name}.h"
#end if
#set $rpc = $elems['rpc-enum']
#for $e in $rpc.req

#if 'request' in $e
int
${e.pre}req_${e.id}(struct galv_rpc_clnt *client,
                    ${e.request.type} ${e.request.asterisk}req,
                    void * ctx)
{
#if $e.request.asterisk
	${assert_fn}(req);
#end if
#else
int
${e.pre}req_${e.id}(struct galv_rpc_clnt *client, void * ctx)
{
#end if
	${assert_fn}(client);

	struct galv_rpc_clnt_msg *msg;
	int                       ret = 0;

	msg = galv_rpc_clnt_create_request(client,
	                                   ${e.pid.upper()},
	                                   ${e.pre}clt_dispatch_${e.id},
	                                   ctx);
	if (!msg)
		return -ENOMEM;
#if 'request' in $e

	ret = ${e.request.encode}(galv_rpc_clnt_msg_encoder(msg), req);
	if (ret)
		goto drop;
#end if

	return galv_rpc_clnt_push_msg(msg);
drop:
	galv_rpc_clnt_msg_drop(msg);
	return ret;
}

#set $goto = 'fini' if 'response' in e and 'fini' in $e.response and $e.response.fini else 'error'
int
${e.pre}clt_dispatch_${e.id}(struct galv_rpc_clnt_msg *msg, int event, void *ctx)
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});
	${assert_fn}(galv_rpc_clnt_msg_type(msg) == GALV_SESS_HEAD_REPLY_TYPE);

#if 'response' in $e
	${e.response.type} param;
#end if
	uint32_t status;
	int ret;
	struct dpack_decoder *decoder = galv_rpc_clnt_msg_decoder(msg);

	if (event) {
		${assert_fn}(event < 0);
#if 'response' in $e
#if $e.response.ampersand
		ret = ${e.pre}clt_${e.id}(ctx, (uint32_t)-event, NULL);
#else
		ret = ${e.pre}clt_${e.id}(ctx, (uint32_t)-event, 0);
#end if
#else
		ret = ${e.pre}clt_${e.id}(ctx, (uint32_t)-event);
#end if
		goto error;
	}

	ret = dpack_decode_uint32(decoder, &status);
	if (ret)
		goto error;
#if 'response' in $e
#if 'init' in $e.response and $e.response.init

	ret = ${e.response.init}(&param);
	if (ret)
		goto error;
#end if

	if (!status) {
		ret = ${e.response.decode}(decoder, &param);
		if (ret)
			goto ${goto};
		ret = ${e.pre}clt_${e.id}(ctx, status, ${e.response.ampersand}param);
	} else
#if $e.response.ampersand
		ret = ${e.pre}clt_${e.id}(ctx, status, NULL);
#else
		ret = ${e.pre}clt_${e.id}(ctx, status, 0);
#end if
#else
	ret = ${e.pre}clt_${e.id}(ctx, status);
#end if

#if 'response' in $e and 'fini' in $e.response and $e.response.fini
fini:
	${e.response.fini}(&param);
#end if
error:
	galv_rpc_clnt_msg_drop(msg);
	return ret;
}
#end for
#for $e in $rpc.evnt
#if 'request' in $e

int
${e.pre}ntf_${e.id}(struct galv_rpc_msg *conn,
                        ${e.request.type} ${e.request.asterisk}req)
{
#if $e.request.asterisk
	${assert_fn}(req);
#end if
#else
int
${e.pre}ntf_${e.id}(struct galv_rpc_msg *conn)
{
#end if
	${assert_fn}(conn);

	struct galv_rpc_msg   *msg;
	int                    ret = 0;

	msg = galv_rpc_create_notif(conn, ${e.pid.upper()});
	if (!msg)
		return -ENOMEM;
#if 'request' in $e

	ret = ${e.request.encode}(galv_rpc_msg_encoder(msg), req);
	if (ret)
		goto drop;
#end if

	return galv_rpc_push_msg(msg);
drop:
	galv_rpc_msg_drop(msg);
	return ret;
}

#set $goto = 'fini' if 'request' in e and 'fini' in $e.request else 'error'
int
${e.pre}clt_dispatch_${e.id}(struct galv_rpc_msg *msg)
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});
	${assert_fn}(galv_rpc_msg_get_type(msg) == GALV_SESS_HEAD_NOTIF_TYPE);

	struct galv_rpc_conn *conn = hed_msg_get_conn(msg);
#if 'request' in $e
	${e.request.type} param;
	int ret;
	struct dpack_decoder *decoder = galv_rpc_msg_decoder(msg);
#if 'init' in $e.request

	ret = ${e.request.init}(&param);
	if (ret)
		goto error;
#end if

	ret = ${e.request.decode}(decoder, &param);
	if (ret)
		goto ${goto};

	ret = ${e.pre}clt_${e.id}(conn, ${e.request.ampersand}param);
#if 'fini' in $e.request
fini:
	${e.request.fini}(&param);
#end if
error:
	galv_rpc_msg_drop(msg);
	return ret;
#else

	galv_rpc_msg_drop(msg);
	return ${e.pre}clt_${e.id}(conn);
#end if
}
#end for

#if 0
static const struct hed_rpc_auth ${pre}clt_auth[] = {
#for $e in $rpc.req + $rpc.evnt
#for $r in $e.roles
	{${e.pid.upper()}, ${r.elem.pid.upper()}, &${e.pre}clt_dispatch_${e.id}},
#end for
#end for
};

const struct galv_rpc_connect_conf
${pre}clt_conf = galv_rpc_connECT_CONF(0,
                                     SOCK_CLOEXEC,
                                     ${pre.upper()}CLT_MAX_PAYLOAD,
                                     CONFIG_HED_BUFF_CAPA_MAX
                                     ${rpc.maxid},
                                     stroll_array_nr(${pre}clt_auth),
                                     &${pre}clt_auth);
#end if
## ex: filetype=c
