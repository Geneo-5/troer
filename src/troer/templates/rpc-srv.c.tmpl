/******************************************************************************
 * SPDX-License-Identifier: LGPL-3.0-only
 *
 * This file is part of ${name}.
 * This file is generated by troer, don't edit manually.
 ******************************************************************************/

#if $kconfig
\#include <${name}/lib.h>
#else if $args.include_prefix
\#include <${args.include_prefix}${name}.h>
#else
\#include "${name}.h"
#end if
#set $rpc = $elems['rpc-enum']
#for $e in $rpc.req

int __${pre}nonull(1) __nothrow __warn_result
#if 'response' in $e
${e.pre}ans_${e.id}(struct hed_rpc_msg *msg,
                    uint32_t status,
                    ${e.response.type} ${e.response.asterisk}ans)
#else
${e.pre}ans_${e.id}(struct hed_rpc_msg *msg,
                    uint32_t status)
#end if
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});

	struct dpack_encoder  encoder;
	int                   ret;

	hed_encoder_init(&encoder, msg);

	ret = dpack_encode_uint32(&encoder, ${e.pid.upper()});
	if (ret)
		goto error;

	ret = dpack_encode_uint32(&encoder, status);
	if (ret)
		goto error;
#if 'response' in $e

	if (!status) {
		${assert_fn}(ans);
		ret = ${e.response.encode}(&encoder, ans);
		if (ret)
			goto error;

	}
#end if

	hed_encoder_fini(&encoder, DPACK_DONE);
	hed_rpc_push_msg(msg);
	return 0;
error:
	hed_encoder_fini(&encoder, DPACK_ABORT);
	hed_rpc_drop_msg(msg);
	return ret;
}
#end for
#for $e in $rpc.evnt
#if 'request' in $e
#set $nl = '1, 2' if $e.request.asterisk else 1

int __${pre}nonull(${nl}) __nothrow __warn_result
${e.pre}ntf_${e.id}(struct hed_rpc_msg *conn,
                        ${e.request.type} ${e.request.asterisk}req)
{
#if $e.request.asterisk
	${assert_fn}(req);
#end if
#else
int __${pre}nonull(1) __nothrow __warn_result
${e.pre}ntf_${e.id}(struct hed_rpc_msg *conn)
{
#end if
	${assert_fn}(conn);

	struct hed_rpc_msg   *msg;
	struct dpack_encoder  encoder;
	int                   ret;

	msg = hed_rpc_alloc_msg(conn);
	if (!msg)
		return -ENOMEM;

	hed_encoder_init(&encoder, msg);

	ret = dpack_encode_uint32(&encoder, ${e.pid.upper()});
	if (ret)
		goto error;
#if 'request' in $e

	ret = ${e.request.encode}(&encoder, req);
	if (ret)
		goto error;
#end if

	hed_encoder_fini(&encoder, DPACK_DONE);
	hed_rpc_push_msg(conn, msg);
	return 0;
error:
	hed_encoder_fini(&encoder, DPACK_ABORT);
	hed_rpc_drop_msg(msg);
	return ret;
}
#end for

#for $e in $rpc.req + $rpc.ntfy
#set $goto = 'fini' if 'request' in e and 'fini' in $e.request else 'error'

int __${pre}nonull(1) __nothrow __warn_result
${e.pre}srv_dispatch_${e.id}(struct hed_rpc_msg *msg)
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});

#if 'request' in $e
	struct dpack_decoder  decoder;
	${e.request.type} param;
	int ret;
#if 'init' in $e.request

	ret = ${e.request.init}(&param);
	if (ret)
		goto error;
#end if
	hed_decoder_init(&decoder, msg);

	ret = ${e.request.decode}(decoder, &param);
	hed_decoder_fini(&decoder);
	if (ret)
		goto ${goto};

	msg = hed_rpc_reply(msg);
	if (!msg) {
		ret = -ENOMEM;
		goto ${goto};
	}

#if 'fini' in $e.request
	ret = ${e.pre}srv_${e.id}(msg, ${e.request.ampersand}param);
	${e.request.fini}(&param);
	return ret;
#else
	return ${e.pre}srv_${e.id}(msg, ${e.request.ampersand}param);
#end if
#if 'fini' in $e.request

fini:
	${e.request.fini}(&param);
#end if
error:
	hed_rpc_drop_msg(msg);
	return ret;
#else

	msg = hed_rpc_reply(msg);
	if (!msg) {
		hed_rpc_drop_msg(msg);
		return -ENOMEM;
	}

	return ${e.pre}srv_${e.id}(msg);
#end if
}
#end for

static const struct hed_rpc_auth ${pre}srv_auth[] = {
#for $e in $rpc.req + $rpc.ntfy
#for $r in $e.roles
	{${e.pid.upper()}, ${r.elem.pid.upper()}, &${e.pre}srv_dispatch_${e.id}},
#end for
#end for
};

const struct hed_rpc_accept_conf
${pre}srv_conf = HED_RPC_ACCEPT_CONF(0,
                                     SOCK_CLOEXEC,
                                     ${pre.upper()}SRV_MAX_PAYLOAD,
                                     CONFIG_HED_BUFF_CAPA_MAX
                                     ${rpc.maxid},
                                     stroll_array_nr(${pre}srv_auth),
                                     &${pre}srv_auth);
## ex: filetype=c
