/******************************************************************************
 * SPDX-License-Identifier: LGPL-3.0-only
 *
 * This file is part of ${name}.
 * This file is generated by troer, don't edit manually.
 ******************************************************************************/

#if $kconfig
\#include <${name}/lib.h>
#else if $args.include_prefix
\#include <${args.include_prefix}${name}.h>
#else
\#include "${name}.h"
#end if
#set $rpc = $elems['rpc-enum']
#for $e in $rpc.req

int __${pre}nonull(1) __nothrow __warn_result
#if 'response' in $e
${e.pre}ans_${e.id}(struct galv_rpc_msg *msg,
                    uint32_t status,
                    ${e.response.type} ${e.response.asterisk}ans)
#else
${e.pre}ans_${e.id}(struct galv_rpc_msg *msg,
                    uint32_t status)
#end if
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});

	struct dpack_encoder *encoder;
	int                   ret;

	encoder = galv_rpc_msg_encoder(msg);
	ret = dpack_encode_uint32(encoder, status);
	if (ret)
		goto error;
#if 'response' in $e

	if (!status) {
#if $e.response.asterisk
		${assert_fn}(ans);
#end if
		ret = ${e.response.encode}(encoder, ans);
		if (ret)
			goto error;

	}
#end if

	return galv_rpc_push_msg(msg);
error:
	return ret;
}
#end for
#for $e in $rpc.evnt
#if 'request' in $e
#set $nl = '1, 2' if $e.request.asterisk else 1

int __${pre}nonull(${nl}) __nothrow __warn_result
${e.pre}ntf_${e.id}(struct galv_rpc_msg *conn,
                        ${e.request.type} ${e.request.asterisk}req)
{
#if $e.request.asterisk
	${assert_fn}(req);
#end if
#else
int __${pre}nonull(1) __nothrow __warn_result
${e.pre}ntf_${e.id}(struct galv_rpc_msg *conn)
{
#end if
	${assert_fn}(conn);

	struct galv_rpc_msg   *msg;
	int                    ret;

	msg = galv_rpc_create_notif(conn, ${e.pid.upper()});
	if (!msg)
		return -ENOMEM;

#if 'request' in $e

	ret = ${e.request.encode}(galv_rpc_msg_encoder(msg), req);
	if (ret)
		goto error;
#end if

	return galv_rpc_push_msg(conn, msg);
error:
	galv_rpc_msg_drop(msg);
	return ret;
}
#end for

#for $e in $rpc.req + $rpc.ntfy
#set $goto = 'fini' if 'request' in e and 'fini' in $e.request and $e.request.fini else 'error'

int __${pre}nonull(1) __nothrow __warn_result
${e.pre}srv_dispatch_${e.id}(struct galv_rpc_msg *msg)
{
	${assert_fn}(msg);
	${assert_fn}(msg->id == ${e.pid.upper()});

	int ret;
#if 'request' in $e
	${e.request.type} param;
#if 'init' in $e.request and $e.request.init

	ret = ${e.request.init}(&param);
	if (ret)
		goto error;
#end if

	ret = ${e.request.decode}(galv_rpc_msg_decoder(msg), &param);
	if (ret)
		goto ${goto};

	ret = galv_rpc_make_reply(msg);
	if (ret)
		goto ${goto};

#if 'fini' in $e.request and $e.request.fini
	ret = ${e.pre}srv_${e.id}(msg, ${e.request.ampersand}param);
	${e.request.fini}(&param);
	return ret;
#else
	return ${e.pre}srv_${e.id}(msg, ${e.request.ampersand}param);
#end if
#if 'fini' in $e.request and $e.request.fini

fini:
	${e.request.fini}(&param);
#end if
error:
	galv_rpc_msg_drop(msg);
	return ret;
#else

	ret = galv_rpc_make_reply(msg);
	if (ret)
		return ret;

	return ${e.pre}srv_${e.id}(msg);
#end if
}
#end for

static struct hed_rpc_auth ${pre}srv_auth[] = {
#for $e in $rpc.req + $rpc.ntfy
#for $r in $e.roles
	{${e.pid.upper()}, ${r.elem.pid.upper()}, &${e.pre}srv_dispatch_${e.id}},
#end for
#end for
};

const struct hed_rpc_factory
${pre}srv_factory = HED_RPC_FACTORY(${rpc.maxid},
                                    stroll_array_nr(${pre}srv_auth),
                                    ${pre}srv_auth);

const struct galv_rpc_accept_conf
${pre}srv_conf = GALV_RPC_ACCEPT_CONF(0,
                                     SOCK_CLOEXEC,
                                     ${pre.upper()}SRV_MAX_PAYLOAD,
                                     CONFIG_HED_BUFF_CAPA_MAX);
## ex: filetype=c
