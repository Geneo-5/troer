static const char * const ${pre}table[] = {
#for $e in $entries
	"${e.name}",
#end for
};
#set $version = str($lib.version)
#set $vlen = len($version)

static int __${pre}nonull(1) __warn_result
${pre}check_${id}_version(struct hed_repo * repo)
{
	${assert_fn}(repo);

	int ret;
	uint8_t *version;
	size_t len;

	ret = hed_repo_start(repo);
	if (ret)
		return ret;

	ret = hed_repo_get_version(repo, &version, &len);
	if (ret)
		goto end;

	if (len != ${vlen}) {
		ret = -EINVAL;
		goto end;

	}

	if (memcmp(version, "${version}", ${vlen}))
		ret = -EINVAL;
end:
	hed_repo_abort(repo);
	return ret;
}

int __${pre}nonull(1, 2) __warn_result
${pre}open_${id}(struct hed_repo * repo, const char * path,
                 int flags, mode_t mode)
{
	${assert_fn}(repo);
	${assert_fn}(path);

	int ret;

	ret = hed_repo_open(repo, path, ${pre}table,
	                    stroll_array_nr(${pre}table),
	                    flags, mode);
	if (ret)
		return ret;

	if (flags & O_TRUNC) {
		ret = hed_repo_start(repo);
		if (ret)
			goto error;

		ret = hed_repo_set_version(repo, (const uint8_t *)"${version}", ${vlen});
		if (ret)
			goto error;

		ret = hed_repo_commit(repo);
		if (ret)
			goto error;
	} else {
		ret = ${pre}check_${id}_version(repo);
		if (ret)
			goto error;
	}
	
	return 0;

error:
	hed_repo_close(repo);
	return ret;
}

extern int __${pre}nonull(1) __warn_result
${pre}reload_${id}(struct hed_repo * repo)
{
	${assert_fn}(repo);

	int ret;

	ret =  hed_repo_reload(repo);
	if (ret)
		return ret;

	ret = ${pre}check_${id}_version(repo);
	if (ret)
		${pre}close_${id}(repo);
	
	return ret;
}

extern int __${pre}nonull(1) __warn_result
${pre}rollback_${id}(struct hed_repo * repo)
{
	${assert_fn}(repo);

	int ret;

	ret =  hed_repo_rollback(repo);
	if (ret)
		return ret;

	ret = ${pre}check_${id}_version(repo);
	if (ret)
		${pre}close_${id}(repo);
	
	return ret;
}

#for $e in $entries
${e.getDefinition()}
#end for
## ex: filetype=c
