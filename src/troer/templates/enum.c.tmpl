struct ${pid}_bisect_entry {
	const char * str;
	${type} value;
};

static const struct ${pid}_bisect_entry ${pid}_bisect_array[] = {
#for $e in sorted($entries, key=lambda x: x.name)
	{"${e.name}", ${e.pid.upper()}},
#end for
};

const char *
${pid}_to_str(${type} value)
{
	unsigned long i;

	for (i = 0; i < stroll_array_nr(${pid}_bisect_array); i++) {
		if (${pid}_bisect_array[i].value == value)
			return ${pid}_bisect_array[i].str;
	}
	return NULL;
}

static int
${pid}_bisect_cmp(const void * __restrict key,
		  const void * __restrict entry,
		  void *                  data __unused)
{
	${assert_fn}(key);
	${assert_fn}(entry);

	const char * k = key;
	const char * e = ((const struct ${pid}_bisect_entry *)entry)->str;
	return strcmp(k, e);
}

int
${pid}_from_str(const char *str, ${type} *value)
{
	${assert_fn}(str);
	${assert_fn}(value);

	const struct ${pid}_bisect_entry *entry;

	entry = stroll_array_bisect_search(str,
					   ${pid}_bisect_array,
					   stroll_array_nr(${pid}_bisect_array),
					   sizeof(${pid}_bisect_array[0]),
					   ${pid}_bisect_cmp,
					   NULL);
	if (!entry)
		return -EINVAL;

	*value = entry->value;
	return 0;
}

int
${pid}_dump_str(const char ** buf, size_t nr __unused)
{
	${assert_fn}(buf);
	${assert_fn}(nr >= ${pid.upper()}_NB);

	unsigned long i;

	for (i = 0; i < stroll_array_nr(${pid}_bisect_array); i++) {
		buf[i] = ${pid}_bisect_array[i].str;
	}
	return ${pid.upper()}_NB;
}
## ex: filetype=c
