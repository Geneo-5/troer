#set $nonull  = '1'
#set $nonull += ', 2' if $key.asterisk else ''
static int __${pre}nonull($nonull) __warn_result
${parent.pid}_${id}_enc_key(MDB_val *idx, ${key.type} ${key.asterisk}key)
{
	${assert_fn}(idx);
	${assert_fn}(idx->mv_data);
#if $key.asterisk
	${assert_fn}(key);
#end if

	int ret;
	struct dpack_encoder enc;

	dpack_encoder_init_buffer(&enc, idx->mv_data,
	                          ${key.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${key.encode}(&enc, key);
	dpack_encoder_fini(&enc, DPACK_DONE);
	if (ret)
		return ret;

	idx->mv_size = (size_t)dpack_encoder_space_used(&enc);
	return 0;
}

#set $nonull  = '1'
#set $nonull += ', 2' if $key.asterisk else ''
#set $nonull += ', 2' if $object.asterisk else ''
int __${pre}nonull($nonull) __warn_result
${parent.pid}_update_${id}(${parent.type} *repo,
                           ${key.type} ${key.asterisk}key,
                           const ${object.type} ${object.asterisk}value)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if
#if $object.asterisk
	${assert_fn}(value);
#end if

	int ret;
	MDB_val idx;
	MDB_val content;
	MDB_dbi dbi;
	struct dpack_encoder enc;
	char idx_buf[${key.elem.pid.upper()}_PACKED_SIZE_MAX];

	idx.mv_data = idx_buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;

	dpack_encoder_init_buffer(&enc, repo->buf,
	                          ${object.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${object.encode}(&enc, value);
	dpack_encoder_fini(&enc, DPACK_DONE);
	if (ret)
		return ret;

	ret = mdb_dbi_open(repo->txn, "${id}", 0, &dbi);
	if (ret)
		return -ret;

	content.mv_data = repo->buf;
	content.mv_size = (size_t)dpack_encoder_space_used(&enc);
	ret = mdb_put(repo->txn, dbi, &idx, &content, 0);
	if (ret)
		return -ret;

	return 0;
}

#set $nonull = '1, 2, 3' if $key.asterisk else '1, 2'
int __${pre}nonull($nonull) __warn_result
${parent.pid}_get_${id}(${parent.type} *repo,
                        ${key.type} ${key.asterisk}key,
                        ${object.type} *value)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if
	${assert_fn}(value);

	int ret;
	MDB_val idx;
	MDB_val content;
	MDB_dbi dbi;
	struct dpack_decoder dec;

	idx.mv_data = repo->buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;

	ret = mdb_dbi_open(repo->txn, "${id}", 0, &dbi);
	if (ret)
		return -ret;

	ret = mdb_get(repo->txn, dbi, &idx, &content);
	if (ret)
		return -ret;
	
	dpack_decoder_init_buffer(&dec, content.mv_data, content.mv_size);
	ret = ${object.decode}(&dec, value);
	dpack_decoder_fini(&dec);
	return ret;
}

#set $nonull = '1, 2' if $key.asterisk else '1'
int __${pre}nonull($nonull) __warn_result
${parent.pid}_del_${id}(${parent.type} *repo,
                           ${key.type} ${key.asterisk}key)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if

	int ret;
	MDB_val idx;
	MDB_dbi dbi;

	idx.mv_data = repo->buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;
	
	ret = mdb_dbi_open(repo->txn, "${id}", 0, &dbi);
	if (ret)
		return -ret;

	ret = mdb_del(repo->txn, dbi, &idx, NULL);
	if (ret)
		return -ret;

	return 0;
}

ssize_t __${pre}nonull(1) __warn_result
${parent.pid}_${id}_count(${parent.type} *repo)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);

	MDB_dbi dbi;
	MDB_stat stat;
	ssize_t ret;

	ret = mdb_dbi_open(repo->txn, "${id}", 0, &dbi);
	if (ret)
		return -ret;

	ret = mdb_stat(repo->txn, dbi, &stat);
	if (ret)
		return -ret;

	return (ssize_t)stat.ms_entries;
}

struct ${pid}_iter * __${pre}nonull(1) __warn_result
${parent.pid}_${id}_create_iter(${parent.type} *repo)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);

	struct ${pid}_iter * iter;
	MDB_dbi dbi;

	if (mdb_dbi_open(repo->txn, "${id}", 0, &dbi))
		return NULL;

	iter = malloc(sizeof(*iter));
	if (!iter)
		return NULL;

	iter->repo = repo;
	if (mdb_cursor_open(repo->txn, dbi, &iter->cursor))
		goto error;

	if (mdb_cursor_get(iter->cursor, NULL, NULL, MDB_FIRST))
		goto error;

	return iter;
error:
	free(iter);
	return NULL;
}

int __${pre}nonull(1) __warn_result
${parent.pid}_${id}_step(struct ${pid}_iter *iter,
                         ${key.type} *key,
                         ${object.type} *value)
{
	${assert_fn}(iter);
	${assert_fn}(iter->repo);
	${assert_fn}(iter->cursor);
	${assert_fn}(!!key | !!value);
	
	struct dpack_decoder  dec;
	MDB_val idx;
	MDB_val content;
	int ret;

	ret = mdb_cursor_get(iter->cursor, &idx, &content, MDB_GET_CURRENT);
	if (ret)
		return -ret;

	if (key) {
		dpack_decoder_init_buffer(&dec, idx.mv_data, idx.mv_size);
		ret = ${key.decode}(&dec, key);
		dpack_decoder_fini(&dec);
		if (ret)
			return ret;
	}

	if (value) {
		dpack_decoder_init_buffer(&dec, content.mv_data, content.mv_size);
		ret = ${object.decode}(&dec, value);
		dpack_decoder_fini(&dec);
		if (ret)
			return ret;
	}

	ret = mdb_cursor_get(iter->cursor, NULL, NULL, MDB_NEXT);
	if (ret)
		return -ret;

	return 0;
}

void __${pre}nonull(1)
${parent.pid}_${id}_destroy_iter(struct ${pid}_iter *iter)
{
	${assert_fn}(iter);
	${assert_fn}(iter->cursor);

	mdb_cursor_close(iter->cursor);
	free(iter);
}

## ex: filetype=c
