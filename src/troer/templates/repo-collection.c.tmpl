#set $nonull  = '1'
#set $nonull += ', 2' if $key.asterisk else ''
static ssize_t __${pre}nonull($nonull) __warn_result
${parent.pid}_${id}_enc_key(uint8_t *data, const ${key.type} ${key.asterisk}key)
{
	${assert_fn}(data);
#if $key.asterisk
	${assert_fn}(key);
#end if

	int ret;
	struct dpack_encoder_buffer enc_buf;
	struct dpack_encoder * enc = (struct dpack_encoder *)&enc_buf;

	dpack_encoder_init_buffer(&enc_buf, data,
	                          ${key.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${key.encode}(enc, key);
	dpack_encoder_fini(enc);
	if (ret < 0)
		return ret;

	return (ssize_t)dpack_encoder_space_used(enc);
}

int
${parent.pid}_update_${id}(struct hed_repo *repo,
                           const ${key.type} ${key.asterisk}key,
                           const ${object.type} ${object.asterisk}value)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if
#if $object.asterisk
	${assert_fn}(value);
#end if

	int ret;
	struct dpack_encoder_buffer enc_buf;
	struct dpack_encoder * enc = (struct dpack_encoder *)&enc_buf;
	ssize_t klen;
	uint8_t key_data[${key.elem.pid.upper()}_PACKED_SIZE_MAX];
	uint8_t value_data[${object.elem.pid.upper()}_PACKED_SIZE_MAX];

	klen = ${parent.pid}_${id}_enc_key(key_data, key);
	if (klen < 0)
		return (int)klen;

	dpack_encoder_init_buffer(&enc_buf, value_data,
	                          ${object.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${object.encode}(enc, value);
	dpack_encoder_fini(enc);
	if (ret)
		return ret;

	return hed_repo_update(repo, "${name}",
	                       key_data, (size_t)klen, value_data,
	                       (size_t)dpack_encoder_space_used(enc));
}

int
${parent.pid}_get_${id}(struct hed_repo *repo,
                        const ${key.type} ${key.asterisk}key,
                        ${object.type} *value)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if
	${assert_fn}(value);

	int ret;
	struct dpack_decoder_buffer dec_buf;
	struct dpack_decoder * dec = (struct dpack_decoder *)&dec_buf;
	ssize_t klen;
	size_t len;
	uint8_t * data;
	uint8_t key_data[${key.elem.pid.upper()}_PACKED_SIZE_MAX];

	klen = ${parent.pid}_${id}_enc_key(key_data, key);
	if (klen < 0)
		return (int)klen;

	ret = hed_repo_get(repo, "${name}",
	                   key_data, (size_t)klen, &data, &len);
	if (ret)
		return ret;

	dpack_decoder_init_buffer(&dec_buf, data, len);
	ret = ${object.decode}(dec, value);
	dpack_decoder_fini(dec);
	return ret;
}

int
${parent.pid}_del_${id}(struct hed_repo *repo,
                        const ${key.type} ${key.asterisk}key)
{
	${assert_fn}(repo);
	${assert_fn}(repo->buf);
	${assert_fn}(repo->env);
	${assert_fn}(repo->txn);
#if $key.asterisk
	${assert_fn}(key);
#end if

	ssize_t klen;
	uint8_t key_data[${key.elem.pid.upper()}_PACKED_SIZE_MAX];

	klen = ${parent.pid}_${id}_enc_key(key_data, key);
	if (klen < 0)
		return (int)klen;

	return hed_repo_del(repo, "${name}", key_data, (size_t)klen);
}


int
${parent.pid}_${id}_step(struct hed_repo_iter *iter,
                         ${key.type} *key,
                         ${object.type} *value)
{
	${assert_fn}(iter);
	${assert_fn}(iter->repo);
	${assert_fn}(iter->cursor);
	${assert_fn}(!!key | !!value);

	struct dpack_decoder_buffer dec_buf;
	struct dpack_decoder * dec = (struct dpack_decoder *)&dec_buf;
	int err;
	int ret;
	size_t klen;
	size_t vlen;
	uint8_t * kdata;
	uint8_t * vdata;


	ret = hed_repo_step(iter, &kdata, &klen, &vdata, &vlen);
	if (ret < 0)
		return ret;

	if (key) {
		dpack_decoder_init_buffer(&dec_buf, kdata, klen);
		err = ${key.decode}(dec, key);
		dpack_decoder_fini(dec);
		if (err)
			return err;
	}

	if (value) {
		dpack_decoder_init_buffer(&dec_buf, vdata, vlen);
		err = ${object.decode}(dec, value);
		dpack_decoder_fini(dec);
		if (err)
			return err;
	}

	return ret;
}

## ex: filetype=c
