#set $nonull  = '1'
#set $nonull += ', 2' if $key.asterisk else ''
static int __${pre}nonull($nonull) __warn_result
${parent.pid}_${id}_enc_key(datum *idx, ${key.type} ${key.asterisk}key)
{
	${assert_fn}(idx);
	${assert_fn}(idx->dptr);
#if $key.asterisk
	${assert_fn}(key);
#end if

	int ret;
	struct dpack_encoder enc;

	dpack_encoder_init_buffer(&enc, idx->dptr,
	                          ${key.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${key.encode}(&enc, key);
	dpack_encoder_fini(&enc, DPACK_DONE);
	if (ret)
		return ret;

	idx->dsize = (int)dpack_encoder_space_used(&enc);
	return 0;
}

#set $nonull  = '1'
#set $nonull += ', 2' if $key.asterisk else ''
#set $nonull += ', 2' if $object.asterisk else ''
int __${pre}nonull($nonull) __warn_result
${parent.pid}_update_${id}(${parent.type} *repo,
                           ${key.type} ${key.asterisk}key,
                           const ${object.type} ${object.asterisk}value)
{
	${assert_fn}(repo);
#if $key.asterisk
	${assert_fn}(key);
#end if
#if $object.asterisk
	${assert_fn}(value);
#end if

	int ret;
	datum idx;
	datum content;
	struct dpack_encoder enc;
	char idx_buf[${key.elem.pid.upper()}_PACKED_SIZE_MAX];

	idx.dptr = idx_buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;

	dpack_encoder_init_buffer(&enc, repo->buf,
	                          ${object.elem.pid.upper()}_PACKED_SIZE_MAX);
	ret = ${object.encode}(&enc, value);
	dpack_encoder_fini(&enc, DPACK_DONE);
	if (ret)
		return ret;

	content.dptr = idx_buf;
	content.dsize = (int)dpack_encoder_space_used(&enc);
	ret = gdbm_store(repo->${id}, idx, content, GDBM_REPLACE);
	if (ret)
		return -EINVAL;

	return 0;
}

#set $nonull = '1, 2, 3' if $key.asterisk else '1, 2'
int __${pre}nonull($nonull) __warn_result
${parent.pid}_get_${id}(${parent.type} *repo,
                        ${key.type} ${key.asterisk}key,
                        ${object.type} *value)
{
	${assert_fn}(repo);
#if $key.asterisk
	${assert_fn}(key);
#end if
	${assert_fn}(value);

	int ret;
	datum idx;
	datum content;
	struct dpack_decoder dec;

	idx.dptr = repo->buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;

	content = gdbm_fetch(repo->${id}, idx);
	if (content.dptr == NULL)
		return -ENOENT;
	
	dpack_decoder_init_buffer(&dec, content.dptr, (size_t)content.dsize);
	ret = ${object.decode}(&dec, value);
	dpack_decoder_fini(&dec);
	free(content.dptr);
	return ret;
}

#set $nonull = '1, 2' if $key.asterisk else '1'
int __${pre}nonull($nonull) __warn_result
${parent.pid}_del_${id}(${parent.type} *repo,
                           ${key.type} ${key.asterisk}key)
{
	${assert_fn}(repo);
#if $key.asterisk
	${assert_fn}(key);
#end if

	int ret;
	datum idx;

	idx.dptr = repo->buf;
	ret = ${parent.pid}_${id}_enc_key(&idx, key);
	if (ret)
		return ret;
	
	if (gdbm_delete(repo->${id}, idx))
		return -ENOENT;

	return 0;
}

ssize_t __${pre}nonull(1) __warn_result
${parent.pid}_${id}_count(${parent.type} *repo)
{
	${assert_fn}(repo);

	gdbm_count_t cnt;

	if (gdbm_count(repo->${id}, &cnt))
		return -EINVAL;

	return (ssize_t)cnt;
}

struct ${pid}_iter * __${pre}nonull(1) __warn_result
${parent.pid}_${id}_create_iter(${parent.type} *repo)
{
	${assert_fn}(repo);

	struct ${pid}_iter * iter;

	iter = malloc(sizeof(*iter));
	if (!iter)
		return NULL;

	iter->repo = repo;
	iter->key = gdbm_firstkey(iter->repo->${id});
	return iter;
}

int __${pre}nonull(1) __warn_result
${parent.pid}_${id}_step(struct ${pid}_iter *iter,
                         ${key.type} *key,
                         ${object.type} *value)
{
	${assert_fn}(iter);
	${assert_fn}(iter->repo);
	${assert_fn}(iter->repo->buf);
	${assert_fn}(iter->key.dptr);
	${assert_fn}(!!key | !!value);
	
	struct dpack_decoder  dec;
	datum content;
	datum next;
	int ret;

	if (key) {
		dpack_decoder_init_buffer(&dec, iter->key.dptr, (size_t)iter->key.dsize);
		ret = ${key.decode}(&dec, key);
		dpack_decoder_fini(&dec);
		if (ret)
			return ret;
	}

	if (value) {
		content = gdbm_fetch(iter->repo->${id}, iter->key);
		${assert_fn}(content.dptr);
		dpack_decoder_init_buffer(&dec, content.dptr, (size_t)content.dsize);
		ret = ${object.decode}(&dec, value);
		dpack_decoder_fini(&dec);
		free(content.dptr);
		if (ret)
			return ret;
	}

	next = gdbm_nextkey(iter->repo->${id}, iter->key);
	free(iter->key.dptr);
	iter->key = next;
	return iter->key.dptr ? EAGAIN : 0;
}

void __${pre}nonull(1)
${parent.pid}_${id}_destroy_iter(struct ${pid}_iter *iter)
{
	${assert_fn}(iter);

	free(iter->key.dptr);
	free(iter);
}

## ex: filetype=c
