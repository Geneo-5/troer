.. SPDX-License-Identifier: MIT-0

   This file is part of ${lib.name}.
   This file is generated by troer, don't edit manually.

.. |Stroll|             replace:: :external+stroll:doc:`Stroll <index>`
.. |Stroll's API guide| replace:: :external+stroll:doc:`Stroll's API guide <api>`

.. |Dpack|              replace:: :external+dpack:doc:`Dpack <index>`
.. |Dapck's API guide|  replace:: :external+dpack:doc:`Dpack's API guide <api>`
.. |MessagePack format| replace:: :external+dpack:doc:`MessagePack format <msgpack>`

.. _jsonc:              https://github.com/json-c/json-c
.. |Json-c|             replace:: `Json-c <jsonc_>`_

.. _pcre2:              https://github.com/PCRE2Project/pcre2
.. |Pcre2|              replace:: `Pcre2 <pcre2_>`_

.. _glibc:              https://www.gnu.org/s/libc/
.. |GLibc|              replace:: `GNU C library <glibc_>`_


Overview
========

What follows here provides a thorough description of how to use
${lib.name.title()}'s library.

Basically, ${lib.name.title()} is a C library that use |Dpack| to (de)serialize
objects according to |MessagePack format|.

Build configuration
===================

At :ref`Build time <workflow-build-phase>`, one build options are available to
customize final ${lib.name} build. From client code, you may eventually refer to
then corresponding C macros listed below:

* :c:macro:`CONFIG_${lib.id.upper()}_ASSERT`

Common definitions
==================

.. _assertions:

Assertions
==========

When compiled with the :c:macro:`CONFIG_${lib.id.upper()}_ASSERT` build
configuration option enabled, the ${lib.name}library exposes the
:c:macro:`${lib.assert_fn}` macro so that developper may perform standard
assertion checking.

#if $lib.json
Json
====


#end if

#for $n in sorted($lib.elems)
#set $e=$lib.elems[$n]
#if $e.isElem('ref')
#continue
#end if
$title($e.name, '-')

#if $e.hasDoc()
$e.doc

#end if
#end for

Reference
=========
#set $D=[ $lib.assert_fn ]
#set $E=[]
#set $S=[]
#set $F=[]
#for $n in $lib.elems
#set $e=$lib.elems[$n]
#if $e.isElem('ref')
#continue
#end if
#set $D += [ f'{e.packed_size}_MAX' ]
#set $D += [ f'{e.packed_size}_MIN' ]
#if $e.isElem('enum')
#set $D += [ f'{e.pid.upper()}_NB' ]
#set $E += [ e.pid ]
#set $F += [ f'{e.pid}_to_str' ]
#set $F += [ f'{e.pid}_from_str' ]
#set $F += [ f'{e.pid}_dump_str' ]
#end if
#if $e.isElem('struct')
#set $S += [ e.pid ]
#end if
#set $F += [ f'{e.check}' ]
#set $F += [ f'{e.decode}' ]
#set $F += [ f'{e.encode}' ]
#if $lib.json
#set $F += [ f'{e.encode}_from_json' ]
#set $F += [ f'{e.decode}_to_json' ]
#end if
#if $e.fini
#set $F += [ f'{e.fini}' ]
#end if
#if $e.init
#set $F += [ f'{e.init}' ]
#end if
#end for

Configuration macros
--------------------
#set $id=$lib.id
$doxyDefine(f"CONFIG_{id.upper()}_ASSERT")

Macros
------
#for $n in sorted($D)
$doxyDefine($n)
#end for

Enums
-----
#for $n in sorted($E)
$doxyEnum($n)
#end for

Structures
----------
#for $n in sorted($S)
$doxyStruct($n)
#end for

Functions
---------
#for $n in sorted($F)
$doxyFunction($n)
#end for
## ex: filetype=rst
