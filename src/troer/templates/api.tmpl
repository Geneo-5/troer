.. SPDX-License-Identifier: LGPL-3.0-only

   This file is part of ${lib.name}.
   This file is generated by troer, don't edit manually.

.. |Stroll|             replace:: :external+stroll:doc:`Stroll <index>`
.. |Stroll's API guide| replace:: :external+stroll:doc:`Stroll's API guide <api>`

.. |Dpack|              replace:: :external+dpack:doc:`Dpack <index>`
.. |Dapck's API guide|  replace:: :external+dpack:doc:`Dpack's API guide <api>`
.. |MessagePack format| replace:: :external+dpack:doc:`MessagePack format <msgpack>`

.. _jsonc:              https://github.com/json-c/json-c
.. |Json-c|             replace:: `Json-c <jsonc_>`_

.. _pcre2:              https://github.com/PCRE2Project/pcre2
.. |Pcre2|              replace:: `Pcre2 <pcre2_>`_

.. _glibc:              https://www.gnu.org/s/libc/
.. |GLibc|              replace:: `GNU C library <glibc_>`_


Overview
========

What follows here provides a thorough description of how to use
${lib.name.title()}'s library.

Basically, ${lib.name.title()} is a C library that use |Dpack| to (de)serialize
objects according to |MessagePack format|.

Build configuration
===================

At :ref`Build time <workflow-build-phase>`, one build options are available to
customize final ${lib.name} build. From client code, you may eventually refer to
then corresponding C macros listed below:

* :c:macro:`CONFIG_${lib.id.upper()}_ASSERT`

Common definitions
==================

.. _assertions:

Assertions
==========

When compiled with the :c:macro:`CONFIG_${lib.id.upper()}_ASSERT` build
configuration option enabled, the ${lib.name}library exposes the
:c:macro:`${lib.assert_fn}` macro so that developper may perform standard
assertion checking.

#if $lib.json
Json
====


#end if

#for $n in sorted($lib.elems)
#set $e=$lib.elems[$n]
#if $e.isElem('ref')
#continue
#end if
$title($e.name, '-')

#if $e.hasDoc()
$e.doc

#end if
#end for

Reference
=========

Configuration macros
--------------------
#set $id=$lib.id
$doxyDefine(f"CONFIG_{id.upper()}_ASSERT")

Macros
------
#for $n in sorted(list($lib.elems) + [$lib.assert_fn])
#if $n == $lib.assert_fn
$doxyDefine($n)
#else
#set $e=$lib.elems[$n]
#if $e.isElem('ref')
#continue
#end if
$doxyDefine(f'{e.packed_size}_MAX')
$doxyDefine(f'{e.packed_size}_MIN')
#if $e.isElem('enum')
$doxyDefine(f'{e.pid.upper()}_NB')
#end if
#end if
#end for

Enums
-----
#for $n in sorted($lib.elems)
#set $e=$lib.elems[$n]
#if $e.isElem('enum')
$doxyEnum(f'{e.pid}')
#end if
#end for

Structures
----------
#for $n in sorted($lib.elems)
#set $e=$lib.elems[$n]
#if $e.isElem('struct')
$doxyStruct(f'{e.pid}')
#end if
#end for

Functions
---------
#set $l=[]
#for $n in $lib.elems
#set $e=$lib.elems[$n]
#if $e.isElem('ref')
#continue
#end if
#if $e.isElem('enum')
#set $l += [f'{e.pid}_to_str']
#set $l += [f'{e.pid}_from_str']
#set $l += [f'{e.pid}_dump_str']
#end if
#set $l += [f'{e.check}']
#set $l += [f'{e.decode}']
#set $l += [f'{e.encode}']
#if $lib.json
#set $l += [f'{e.encode}_from_json']
#set $l += [f'{e.decode}_to_json']
#end if
#if $e.fini
#set $l += [f'{e.fini}']
#end if
#if $e.init
#set $l += [f'{e.init}']
#end if
#end for
#for $n in sorted($l)
$doxyFunction($n)
#end for
## ex: filetype=rst
